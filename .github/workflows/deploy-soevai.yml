name: Production build on IP + Domain

on:
  workflow_dispatch:
    inputs:
      ip:
        description: 'ip address of the production server'
        type: string
      domain:
        description: 'Domain of the production server'
        type: string
        default: chat.sovai.nl
      tag_version:
        description: 'Image tag to deploy'
        type: string
        default: latest
      config_path:
        description: 'Config path to deploy'
        type: string
        default: librechat.soev.ai.yaml
      allow_registration:
        description: 'Allow registration'
        type: boolean
        default: true
      app_title:
        description: 'App title'
        type: string
        default: soev.ai

env:
  SSH_PRIVATE_KEY_PROD: ${{ secrets.SSH_PRIVATE_KEY_PROD }}
  GRADIENT_MAIL: ${{ secrets.GRADIENT_MAIL }}
  SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

jobs:
  production:
    runs-on: ubuntu-latest
    timeout-minutes: 120

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Wait for SSH (port 22)
        run: |
          set -euo pipefail
          ip=${{ inputs.ip }}
          for i in {1..60}; do
            if (echo > /dev/tcp/$ip/22) >/dev/null 2>&1; then exit 0; fi
            echo "Waiting for SSH ($i/60) ..."; sleep 5
          done
          exit 1

      - name: Prepare SSH key
        id: ssh
        env:
          SSH_PRIVATE_KEY_PROD: ${{ env.SSH_PRIVATE_KEY_PROD }}
        run: |
          mkdir -p ~/.ssh
          echo "$SSH_PRIVATE_KEY_PROD" > ~/.ssh/id_do
          chmod 600 ~/.ssh/id_do
          echo "key_path=$HOME/.ssh/id_do" >> $GITHUB_OUTPUT

      - name: Select SSH control user
        id: ctrl
        run: |
          set -euo pipefail
          IP=${{ inputs.ip }}
          KEY=${{ steps.ssh.outputs.key_path }}

          try_user() {
            local user="$1"; shift || true
            echo "[debug] trying SSH as '$user' ..."
            if ssh -o StrictHostKeyChecking=no -o BatchMode=yes -o ConnectTimeout=5 -i "$KEY" "$user@$IP" "echo ok" >/dev/null 2>&1; then
              echo "[debug] SSH ok as '$user'"
              return 0
            else
              rc=$?
              echo "[debug] SSH failed as '$user' (rc=$rc)"
              return 1
            fi
          }

          for U in root; do
            if try_user "$U"; then
              echo "ssh_user=$U" >> $GITHUB_OUTPUT
              echo "mode=needs-bootstrap" >> $GITHUB_OUTPUT
              exit 0
            fi
          done

          if try_user deploy; then
            echo "ssh_user=deploy" >> $GITHUB_OUTPUT
            KEY_ESCAPED="$KEY"
            if ssh -o StrictHostKeyChecking=no -o BatchMode=yes -o ConnectTimeout=5 -i "$KEY_ESCAPED" "deploy@$IP" "sudo -n /usr/bin/ls /" >/dev/null 2>&1; then
              echo "mode=deploy-ready" >> $GITHUB_OUTPUT
            else
              echo "mode=deploy-no-sudo" >> $GITHUB_OUTPUT
            fi
            exit 0
          fi

          echo "No suitable SSH user found (tried root, deploy)." >&2
          exit 1

      - name: Bootstrap/repair deploy (if needed)
        if: steps.ctrl.outputs.mode == 'needs-bootstrap'
        run: |
          set -euo pipefail
          IP=${{ inputs.ip }}
          KEY=${{ steps.ssh.outputs.key_path }}
          BOOT=${{ steps.ctrl.outputs.ssh_user }}

          ssh -o StrictHostKeyChecking=no -i "$KEY" "$BOOT@$IP" bash -s <<'REMOTE'
          set -euo pipefail

          if ! id deploy >/dev/null 2>&1; then
            sudo useradd -m -s /bin/bash -G sudo,adm deploy
          fi
          sudo install -d -m 0700 -o deploy -g deploy /home/deploy/.ssh
          if [ -r "$HOME/.ssh/authorized_keys" ]; then
            sudo install -m 0600 -o deploy -g deploy "$HOME/.ssh/authorized_keys" /home/deploy/.ssh/authorized_keys
          fi

          TMP=$(mktemp)
          cat > "$TMP" <<'SUDOERS'
          Defaults:deploy secure_path="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
          deploy ALL=(ALL) NOPASSWD:ALL
          SUDOERS
          sudo visudo -cf "$TMP"
          sudo install -m 0440 "$TMP" /etc/sudoers.d/90-deploy
          sudo chown root:root /etc/sudoers.d/90-deploy
          rm -f "$TMP"

          sudo usermod -aG docker deploy || true
          echo "Deploy user bootstrapped."
          REMOTE

      - name: Wait for SSH deploy (with sudo)
        if: steps.ctrl.outputs.mode == 'deploy-ready'
        run: |
          set -euo pipefail
          ip=${{ inputs.ip }}
          key=${{ steps.ssh.outputs.key_path }}
          for i in {1..90}; do
            if ssh -o StrictHostKeyChecking=no -o BatchMode=yes -o ConnectTimeout=5 -i "$key" deploy@"$ip" "sudo -n /usr/bin/ls /" >/dev/null 2>&1; then
              echo "SSH deploy ready"; exit 0; fi
            echo "Waiting for deploy sudo ($i/90) ..."; sleep 5
          done
          echo "deploy reachable but sudo -n failed." >&2; exit 1

      - name: Bootstrap production VM (idempotent, via deploy)
        run: |
          IP=${{ inputs.ip }}
          ssh -o StrictHostKeyChecking=no -i "${{ steps.ssh.outputs.key_path }}" deploy@"$IP" bash -s <<'REMOTE'
          set -euo pipefail
          export DEBIAN_FRONTEND=noninteractive

          sudon() { sudo -n "$@"; }

          TMP_SUDOERS=$(mktemp)
          cat > "$TMP_SUDOERS" <<'SUDOERS'
          Defaults:deploy secure_path="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
          deploy ALL=(ALL) NOPASSWD: \
            /usr/bin/docker, \
            /usr/bin/systemctl, \
            /usr/bin/journalctl, \
            /usr/bin/apt-get, \
            /usr/bin/apt, \
            /usr/sbin/usermod, \
            /usr/sbin/ufw, \
            /usr/sbin/visudo, \
            /usr/bin/install, \
            /bin/mkdir, /usr/bin/mkdir, \
            /bin/chmod, /usr/bin/chmod, \
            /bin/chown, /usr/bin/chown, \
            /usr/bin/curl, \
            /usr/bin/tar, \
            /usr/bin/tee, \
            /usr/bin/tail, \
            /usr/bin/cloud-init, \
            /bin/cp, /usr/bin/cp, \
            /bin/ls, /usr/bin/ls, \
            /usr/bin/stat, \
            /usr/bin/test, \
            /usr/bin/openssl, \
            /usr/bin/sed
          SUDOERS
          sudon visudo -cf "$TMP_SUDOERS"
          sudon install -m 0440 "$TMP_SUDOERS" /etc/sudoers.d/90-deploy
          sudon chown root:root /etc/sudoers.d/90-deploy
          rm -f "$TMP_SUDOERS"

          set +e
          ok=""
          for i in {1..30}; do
            if sudon apt-get update -y && sudon apt-get install -y ca-certificates curl git python3 python3-pip docker.io ufw fail2ban unattended-upgrades auditd; then
              ok=1; break; fi
            echo "[keepalive] apt busy; retry $i/30"; sleep 5
          done
          set -e
          if [ -z "$ok" ]; then echo "apt install failed after retries" >&2; exit 1; fi

          if ! docker compose version >/dev/null 2>&1; then
            sudon mkdir -p /usr/lib/docker/cli-plugins
            sudon curl -sSL -o /usr/lib/docker/cli-plugins/docker-compose \
              https://github.com/docker/compose/releases/download/v2.39.1/docker-compose-linux-x86_64
            sudon chmod +x /usr/lib/docker/cli-plugins/docker-compose
          fi
          sudon usermod -aG docker deploy || true

          sudon mkdir -p /etc/ssh/sshd_config.d
          TS="/etc/ssh/sshd_config.d/01-hardening.conf"
          TMP_SSH=$(mktemp)
          cat > "$TMP_SSH" <<'SSHDROPIN'
          PasswordAuthentication no
          KbdInteractiveAuthentication no
          PermitRootLogin no
          PubkeyAuthentication yes
          X11Forwarding no
          UseDNS no
          AllowUsers deploy
          SSHDROPIN
          if ! cmp -s "$TMP_SSH" "$TS" 2>/dev/null; then
            sudon install -m 0644 "$TMP_SSH" "$TS"
            sudon systemctl reload ssh || sudon systemctl reload sshd || true
          fi
          rm -f "$TMP_SSH"

          sudon install -d -m 0775 -o deploy -g deploy \
            /srv/soevai/letsencrypt \
            /srv/soevai/certbot-www \
            /srv/soevai/letsencrypt-log

          sudon ufw --force reset || true
          sudon ufw default deny incoming
          sudon ufw default allow outgoing
          sudon ufw limit 22/tcp
          sudon ufw allow 80/tcp
          sudon ufw allow 443/tcp
          sudon ufw --force enable

          sudon systemctl enable --now docker || true
          sudon systemctl enable --now fail2ban || true
          sudon systemctl enable --now auditd || true
          echo 'APT::Periodic::Update-Package-Lists "1";'          | sudon tee /etc/apt/apt.conf.d/20auto-upgrades >/dev/null
          echo 'APT::Periodic::Download-Upgradeable-Packages "1";' | sudon tee -a /etc/apt/apt.conf.d/20auto-upgrades >/dev/null
          echo 'APT::Periodic::AutocleanInterval "7";'             | sudon tee -a /etc/apt/apt.conf.d/20auto-upgrades >/dev/null
          echo 'APT::Periodic::Unattended-Upgrade "1";'            | sudon tee -a /etc/apt/apt.conf.d/20auto-upgrades >/dev/null
          sudon systemctl enable --now unattended-upgrades || true

          sudon visudo -cf /etc/sudoers.d/90-deploy
          REMOTE

      - name: Upload deployment bundle and runtime env
        env:
          TAG_VERSION: ${{ inputs.tag_version }}
          GH_PAT: ${{ secrets.GH_PAT }}
          GHCR_USERNAME: ${{ secrets.GHCR_USERNAME }}
          GRADIENT_MAIL: ${{ secrets.GRADIENT_MAIL }}
          CONFIG_PATH: ${{ inputs.config_path }}
          HF_KEY: ${{ secrets.HF_KEY }}
          GKN_API_KEY: ${{ secrets.GKN_API_KEY }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          CREDS_KEY: ${{ secrets.CREDS_KEY }}
          CREDS_IV: ${{ secrets.CREDS_IV }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          JWT_REFRESH_SECRET: ${{ secrets.JWT_REFRESH_SECRET }}
          RAG_OPENAI_API_KEY: ${{ secrets.RAG_OPENAI_API_KEY }}
          RAG_API_URL: ${{ vars.RAG_API_URL }}
          ALLOW_REGISTRATION: ${{ inputs.allow_registration }}
          ALLOW_EMAIL_LOGIN: ${{ vars.allow_email_login }}
          ALLOW_UNVERIFIED_EMAIL_LOGIN: ${{ vars.allow_unverified_email_login }}
          EMAIL_FROM: ${{vars.EMAIL_FROM}}
          SMTP_HOST: ${{vars.SMTP_HOST}}
          SMTP_PORT: ${{vars.SMTP_PORT}}
          SMTP_USER: ${{vars.SMTP_USER}}
          SMTP_SECURE: ${{vars.SMTP_SECURE}}
          SMTP_PASSWORD: ${{secrets.SMTP_PASSWORD}}
          APP_TITLE: ${{ inputs.app_title }}
          SERPER_API_KEY: ${{ secrets.SERPER_API_KEY }}
          WEBSEARCH_SEARCH_PROVIDER: ${{ vars.websearch_search_provider }}
          FIRECRAWL_API_KEY: ${{ secrets.FIRECRAWL_API_KEY }}
          COHERE_API_KEY: ${{ secrets.COHERE_API_KEY }}
          MEILI_MASTER_KEY: ${{ secrets.MEILI_MASTER_KEY }}
          ENDPOINTS: ${{ vars.ENDPOINTS }}
        run: |
          set -euo pipefail
          ip=${{ inputs.ip }}
          fqdn=${{ inputs.domain }}
          dir=/home/deploy/soevai
          mkdir -p bundle
          tar -czf bundle/deploy.tar.gz deploy-compose.soev.ai.yml client/nginx.conf client/nginx-acme.conf client/nginx.tmpl.conf librechat.soev.ai.yaml admin-overrides.yaml
          scp -o StrictHostKeyChecking=no -i "${{ steps.ssh.outputs.key_path }}" bundle/deploy.tar.gz deploy@"$ip":/home/deploy/deploy.tar.gz
          {
            printf 'FQDN=%q\n' "$fqdn"
            printf 'IP=%q\n' "$ip"
            printf 'LIBRECHAT_TAG=%q\n' "$TAG_VERSION"
            printf 'GH_PAT=%q\n' "$GH_PAT"
            printf 'GHCR_USERNAME=%q\n' "$GHCR_USERNAME"
            printf 'CONFIG_PATH=%q\n' "$CONFIG_PATH"
            printf 'HF_KEY=%q\n' "$HF_KEY"
            printf 'GRADIENT_MAIL=%q\n' "$GRADIENT_MAIL"
            printf 'GKN_API_KEY=%q\n' "$GKN_API_KEY"
            printf 'OPENAI_API_KEY=%q\n' "$OPENAI_API_KEY"
            printf 'CREDS_KEY=%q\n' "$CREDS_KEY"
            printf 'CREDS_IV=%q\n' "$CREDS_IV"
            printf 'JWT_SECRET=%q\n' "$JWT_SECRET"
            printf 'JWT_REFRESH_SECRET=%q\n' "$JWT_REFRESH_SECRET"
            printf 'RAG_OPENAI_API_KEY=%q\n' "$RAG_OPENAI_API_KEY"
            printf 'RAG_API_URL=%q\n' "$RAG_API_URL"
            printf 'ALLOW_REGISTRATION=%q\n' "$ALLOW_REGISTRATION"
            printf 'ALLOW_EMAIL_LOGIN=%q\n' "$ALLOW_EMAIL_LOGIN"
            printf 'ALLOW_UNVERIFIED_EMAIL_LOGIN=%q\n' "$ALLOW_UNVERIFIED_EMAIL_LOGIN"
            printf '%s=%s\n' "EMAIL_FROM" "\"$EMAIL_FROM\""
            printf 'SMTP_HOST=%q\n' "$SMTP_HOST"
            printf 'SMTP_PORT=%q\n' "$SMTP_PORT"
            printf 'SMTP_USER=%q\n' "$SMTP_USER"
            printf 'SMTP_SECURE=%q\n' "$SMTP_SECURE"
            printf 'SMTP_PASSWORD=%q\n' "$SMTP_PASSWORD"
            printf 'APP_TITLE=%q\n' "$APP_TITLE"
            printf 'SERPER_API_KEY=%q\n' "$SERPER_API_KEY"
            printf 'WEBSEARCH_SEARCH_PROVIDER=%q\n' "$WEBSEARCH_SEARCH_PROVIDER"
            printf 'FIRECRAWL_API_KEY=%q\n' "$FIRECRAWL_API_KEY"
            printf 'COHERE_API_KEY=%q\n' "$COHERE_API_KEY"
            printf 'MEILI_MASTER_KEY=%q\n' "$MEILI_MASTER_KEY"
            printf 'DOMAIN_CLIENT=%q\n' "https://$fqdn"
            printf 'DOMAIN_SERVER=%q\n' "https://$fqdn"
            printf 'TRUST_PROXY=%q\n' "1"
            printf '%s=%s\n' "ENDPOINTS" "$ENDPOINTS"
          } > .remote.env
          scp -o StrictHostKeyChecking=no -i "${{ steps.ssh.outputs.key_path }}" .remote.env deploy@"$ip":/home/deploy/.remote.env

      - name: Authenticate to GHCR on remote
        run: |
          ip=${{ inputs.ip }}
          ssh -o StrictHostKeyChecking=no -i "${{ steps.ssh.outputs.key_path }}" deploy@"$ip" bash -lc '
            set -euo pipefail
            [ -f /home/deploy/.remote.env ] && . /home/deploy/.remote.env || true
            USERNAME="${GHCR_USERNAME:-${GITHUB_ACTOR:-}}"
            TOKEN="${GH_PAT:-}"
            if [ -z "$TOKEN" ]; then
              echo "GH_PAT not set; cannot login to GHCR." >&2
              exit 1
            fi
            mkdir -p /home/deploy/.docker && chmod 700 /home/deploy/.docker
            docker logout ghcr.io >/dev/null 2>&1 || true
            echo "$TOKEN" | docker login ghcr.io -u "$USERNAME" --password-stdin
            echo "Logged into GHCR as $USERNAME (deploy)"
            sudo mkdir -p /root/.docker && sudo chmod 700 /root/.docker
            sudo docker logout ghcr.io >/dev/null 2>&1 || true
            echo "$TOKEN" | sudo docker login ghcr.io -u "$USERNAME" --password-stdin
            echo "Logged into GHCR as $USERNAME (root)"
          '

      - name: Remote bootstrap (extract bundle, start stack HTTP)
        run: |
          ip=${{ inputs.ip }}
          ssh -o StrictHostKeyChecking=no -i "${{ steps.ssh.outputs.key_path }}" deploy@"$ip" bash -lc '
            set -euo pipefail
            mkdir -p /home/deploy/soevai && cd /home/deploy/soevai
            tar -xzf /home/deploy/deploy.tar.gz
            . /home/deploy/.remote.env || true
            export HOST=0.0.0.0
            export PORT=3080
            export DOMAIN_CLIENT="https://$FQDN"
            export DOMAIN_SERVER="https://$FQDN"
            export TRUST_PROXY=1
            export ALLOW_REGISTRATION=true
            export ALLOW_UNVERIFIED_EMAIL_LOGIN=true
            docker compose --env-file /home/deploy/.remote.env -f deploy-compose.soev.ai.yml pull | cat
            docker compose --env-file /home/deploy/.remote.env -f deploy-compose.soev.ai.yml up -d | cat
          '

      - name: Wait for DNS propagation (A record)
        run: |
          set -euo pipefail
          fqdn=${{ inputs.domain }}
          ip=${{ inputs.ip }}
          for resolver in 1.1.1.1 8.8.8.8 9.9.9.9; do
            echo "Checking resolver $resolver for $fqdn -> $ip"
            ok=""
            for i in {1..60}; do
              resolved=$(dig +short A "$fqdn" @"$resolver" | tail -n1 || true)
              if [ "$resolved" = "$ip" ]; then ok=1; break; fi
              echo "  waiting DNS ($i/60): got '$resolved'"; sleep 5
            done
            if [ -z "$ok" ]; then echo "Resolver $resolver does not return $ip for $fqdn" >&2; exit 1; fi
          done

      - name: Bootstrap Nginx with ACME and issue certificate
        env:
          GRADIENT_MAIL: ${{ secrets.GRADIENT_MAIL }}
        run: |
          ip=${{ inputs.ip }}
          fqdn=${{ inputs.domain }}
          ssh -o StrictHostKeyChecking=no -i "${{ steps.ssh.outputs.key_path }}" deploy@"$ip" bash -s <<'REMOTE'
          set -euo pipefail
          cd /home/deploy/soevai
          . /home/deploy/.remote.env || true

          : "${GRADIENT_MAIL:=}"
          if [ -z "$GRADIENT_MAIL" ]; then
            echo "GRADIENT_MAIL not set; skipping cert issuance"
            exit 0
          fi

          # 1) ACME bootstrap config (HTTP only)
          sed "s/SERVER_NAME_PLACEHOLDER/${FQDN}/g" client/nginx-acme.conf > /tmp/nginx-default.conf

          # Write in-place instead of docker cp (works with bind mounts)
          docker exec -i nginx-soevai sh -c 'cat > /etc/nginx/conf.d/default.conf' < /tmp/nginx-default.conf
          docker exec nginx-soevai nginx -t
          docker exec nginx-soevai nginx -s reload

          # Wait until HTTP is actually answering
          for i in $(seq 1 60); do
            if curl -fsS "http://$FQDN/" >/dev/null 2>&1; then break; fi
            sleep 2
          done

          # 2) Issue certificate via webroot
          sudo mkdir -p /srv/soevai/letsencrypt /srv/soevai/certbot-www /srv/soevai/letsencrypt-log
          sudo docker run --rm \
            -v "/srv/soevai/letsencrypt:/etc/letsencrypt" \
            -v "/srv/soevai/certbot-www:/var/www/certbot" \
            -v "/srv/soevai/letsencrypt-log:/var/log/letsencrypt" \
            certbot/certbot:latest certonly --webroot \
              -w /var/www/certbot -d "$FQDN" \
              --agree-tos --email "$GRADIENT_MAIL" --non-interactive -v

          sudo ls -l "/srv/soevai/letsencrypt/live/$FQDN/fullchain.pem" "/srv/soevai/letsencrypt/live/$FQDN/privkey.pem"

          # Wait for API to be ready before switching to TLS
          echo "Waiting for API health (host 127.0.0.1:3080) ..."
          ok=""
          for i in $(seq 1 120); do
            code=$(curl -sS -o /dev/null -w "%{http_code}" http://127.0.0.1:3080/health || true)
            if [ "$code" = "200" ]; then ok=1; break; fi
            sleep 2
          done
          if [ -z "$ok" ]; then
            echo "API health not ready on host after waiting; checking from nginx container ..."
            docker exec nginx-soevai sh -lc 'apk add --no-cache curl >/dev/null 2>&1 || true; curl -sS -o /dev/null -w "%{http_code}" http://api:3080/health || true'
          fi

          # Ensure TLS helper files exist on host (visible in container via bind mount)
          sudo mkdir -p /srv/soevai/letsencrypt
          if [ ! -f /srv/soevai/letsencrypt/options-ssl-nginx.conf ]; then
            sudo tee /srv/soevai/letsencrypt/options-ssl-nginx.conf >/dev/null <<'EOF'
          ssl_protocols TLSv1.2 TLSv1.3;
          ssl_prefer_server_ciphers off;
          ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305;
          ssl_session_timeout 1d;
          ssl_session_cache shared:SSL:10m;
          ssl_session_tickets off;
          EOF
          fi
          if [ ! -f /srv/soevai/letsencrypt/ssl-dhparams.pem ]; then
            sudo openssl dhparam -out /srv/soevai/letsencrypt/ssl-dhparams.pem 2048
          fi

          # 3) Switch to TLS config and reload
          sed "s/SERVER_NAME_PLACEHOLDER/${FQDN}/g" client/nginx.tmpl.conf > /tmp/nginx-default.conf
          docker exec -i nginx-soevai sh -c 'cat > /etc/nginx/conf.d/default.conf' < /tmp/nginx-default.conf
          docker exec nginx-soevai nginx -t
          docker exec nginx-soevai nginx -s reload
          REMOTE

      - name: Ensure LE TLS helper files exist
        run: |
          IP=${{ inputs.ip }}
          ssh -o StrictHostKeyChecking=no -i "${{ steps.ssh.outputs.key_path }}" deploy@"$IP" bash -s <<'REMOTE'
          set -euo pipefail
          sudo mkdir -p /srv/soevai/letsencrypt
          if [ ! -f /srv/soevai/letsencrypt/options-ssl-nginx.conf ]; then
            sudo tee /srv/soevai/letsencrypt/options-ssl-nginx.conf >/dev/null <<'EOF'
          ssl_protocols TLSv1.2 TLSv1.3;
          ssl_prefer_server_ciphers off;
          ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305;
          ssl_session_timeout 1d;
          ssl_session_cache shared:SSL:10m;
          ssl_session_tickets off;
          EOF
          fi
          if [ ! -f /srv/soevai/letsencrypt/ssl-dhparams.pem ]; then
            sudo openssl dhparam -out /srv/soevai/letsencrypt/ssl-dhparams.pem 2048
          fi
          REMOTE

      - name: Smoke tests (remote)
        run: |
          fqdn=${{ inputs.domain }}
          for i in {1..60}; do
            code=$(curl -sS -o /dev/null -w "%{http_code}" "https://$fqdn/")
            if [ "$code" -ge 200 ] && [ "$code" -lt 500 ]; then break; fi
            echo "Waiting for HTTPS ($i/60) ..."; sleep 2
          done
          curl -fsS "https://$fqdn/" >/dev/null

      - name: Collect container logs (success)
        if: success()
        run: |
          ip=${{ inputs.ip }}
          ssh -o StrictHostKeyChecking=no -i "${{ steps.ssh.outputs.key_path }}" deploy@"$ip" bash -lc '
            set -euo pipefail
            cd /home/deploy/soevai
            echo "=== docker compose ps ==="; docker compose -f deploy-compose.soev.ai.yml ps | cat
            echo
            echo "=== API logs: librechat_api (last 300) ==="; docker logs --tail=300 librechat_api || true
            echo
            echo "=== Nginx logs: nginx-soevai (last 200) ==="; docker logs --tail=200 nginx-soevai || true
            echo
            echo "=== Mongo logs: chat-mongodb (last 100) ==="; docker logs --tail=100 chat-mongodb || true
            echo
            echo "=== Meilisearch logs: chat-meilisearch (last 100) ==="; docker logs --tail=100 chat-meilisearch || true
            echo
            echo "=== Certbot logs: certbot-soevai (last 100) ==="; docker logs --tail=100 certbot-soevai || true
            echo
            echo "=== VectorDB logs: soevai-vectordb-1 (last 100) ==="; docker logs --tail=100 soevai-vectordb-1 || true
            echo
            echo "=== RAG API logs: soevai-rag_api-1 (last 100) ==="; docker logs --tail=100 soevai-rag_api-1 || true
            echo
            echo "=== All compose logs (last 200, all services) ==="; docker compose -f deploy-compose.soev.ai.yml logs --no-color --tail=200 | cat || true
          '

      - name: Debug nginx/api on failure
        if: failure()
        run: |
          ip=${{ inputs.ip }}
          ssh -o StrictHostKeyChecking=no -i "${{ steps.ssh.outputs.key_path }}" deploy@"$ip" bash -lc '
            set -euo pipefail
            echo "=== docker compose ps ==="; docker compose -f /home/deploy/soevai/deploy-compose.soev.ai.yml ps | cat
            echo
            echo "=== nginx config (nginx -T, last 120 lines) ==="; docker exec nginx-soevai sh -lc "nginx -T 2>&1 | tail -n 120" || true
            echo
            echo "=== nginx logs (last 200) ==="; docker logs --tail=200 nginx-soevai || true
            echo
            echo "=== api logs (last 200) ==="; docker logs --tail=200 librechat_api || true
            echo
            echo "=== DNS inside nginx ==="; docker exec nginx-soevai getent hosts api librechat_api || true
            echo
            echo "=== API health from host ==="; curl -sS -o /dev/null -w "%{http_code}\n" http://127.0.0.1:3080/health || true
          '

